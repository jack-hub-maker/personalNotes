##  常见http状态码及对应含义：

 200: '服务器成功返回请求的数据。',

 201: '新建或修改数据成功。',

 202: '一个请求已经进入后台排队（异步任务）。',

 204: '处理成功，但不需要返回任何实体内容',

 301: '永久重定向',

 302: '临时重定向',

 304: '缓存',

 400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。',

 401: '用户没有权限（令牌、用户名、密码错误）。',

 402: '未来预留位置',

 403: '用户得到授权，但是访问是被禁止的。',

 404: '发出的请求针对的是不存在的记录，服务器没有进行操作。',

 410: '请求的资源被永久删除，且不会再得到的。',

 500: '服务器发生错误，请检查服务器。',

 502: '网关错误。',

 503: '服务不可用，服务器暂时过载或维护。',

 504: '网关超时。',



## 关于301和302重定向的扩展：

#### 1. 定义

如果要将内容永久移动到新位置，用301重定向。如果暂时移动它，用302重定向。

#### 2. 缓存

对于301请求，浏览器是默认给一个很长的缓存。而302是不缓存的。

#### 3. 搜索引擎

301: 旧地址A的资源不可访问了(永久移除), 重定向到网址B，搜索引擎会抓取网址B的内容，同时将网址保存为B网址。如果你希望新地址被seo搜索到的话，使用301更合适

302: 旧地址A的资源仍可访问，这个重定向只是临时从旧地址A跳转到B地址，这时搜索引擎会抓取B网址内容，但是会将网址保存为A的。

#### 4. 安全

尽量使用301跳转，以防止网址劫持！

假如A -> B。大部分的搜索引擎在大部分情况下，当收到302 重定向时，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL 网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google 很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL 劫持的可能性。所以出于某种原因， Google 搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持

#### 5.具体使用

http 向 https 做重定向应该使用哪个状态码?

一般用作 `301` 的较为多，但是也有使用 `302`，如淘宝使用了 301，知乎使用了 302

## 关于304浏览器缓存的扩展：

#### 定义

所谓浏览器缓存其实就是指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。

#### 哪些资源可以被缓存？

——静态资源（js、css、img）但html不行，因为网站在使用过程中 `html` 随时有可能被更新，随时有可能被替换模板，而且网页的业务数据也是不能被缓存的。

#### 缓存位置

从缓存位置上来说分为四种，当依次查找缓存且都没有命中的时候，才会去请求网络

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂

#### 缓存策略

通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的

##### 强缓存

强缓存定义：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

强缓存实现：我们第一次进入页面，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中expires、pragma或者cache-control字段，代表这是强缓存，浏览器就会把资源缓存在memory cache 或 disk cache中。

第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码200，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否符合协商缓存，符合则返回状态码304，不符合则服务器会返回全新资源。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca00bff3081e4cfd993a8f252f4fa23a~tplv-k3u1fbpfcp-watermark.awebp)

关于 HTTP Header ：Expires 和 Cache-Control。 

1.Expires 是HTTP1.0控制网页缓存的字段，值为一个时间戳，是服务器返回该请求结果缓存的到期时间，意思是，再次发送请求时，如果未超过过期时间，直接使用该缓存，如果过期了则重新请求。缺点是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。

 2.Cache-Control 是HTTP1.1中控制网页缓存的字段，当Cache-Control都存在时，Cache-Control优先级更高，Cache-Control使用了max-age相对时间，解决了expires的问题。

比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。他是指距离过期还有多少时间。

3.Expires和Cache-Control两者对比 其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。 强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。



##### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回304和Not Modified
- 协商缓存失效，返回200和请求结果

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。

Last-Modified/If-Modified-Since是服务器响应请求时，返回该资源文件在服务器最后被修改时间

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c3aabbfd9a43ab81c97dd519da3b9f~tplv-k3u1fbpfcp-watermark.awebp)

If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa2eae3bc57d48e39a871c8e659bf97d~tplv-k3u1fbpfcp-watermark.awebp)



Etag/ If-None-Match是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)。

![qq 20160821235958](https://cloud.githubusercontent.com/assets/7554325/17838274/039cbe28-67fc-11e6-9cc6-19f21fb4eb1b.png)

If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。



> **关于资源标识**
>
> 在响应头部 `Response Headers` 中，**有两种资源标识：**
>
> - `Last-Modified` 资源的最后修改时间，对应请求头为 `If-Modified-Since` ；
> - `Etag` 资源的唯一标识，所谓唯一，可以想象成时人类的指纹，具有唯一性；但 `Etag` 的本质是一个字符串；对应请求头为 `If-None-Match` 。
>
> **关于Last-Modified 和 Etag**
>
> - 当响应头部 `Response Headers` 同时存在 `Last-Modified` 和 `Etag` 的值时，会优先使用 `Etag` ；
> - `Last-Modified` 只能精确到秒级；
> - 如果资源被重复生成，而内容不变，则 `Etag` 更精确。




###  缓存方案

目前的项目大多使用这种缓存方案的：

- HTML: 协商缓存；
- css、js、图片：强缓存，文件名带上hash。

### 强缓存与协商缓存的区别

1. 强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。

2. 大部分web服务器都默认开启协商缓存。

### 刷新对于强缓存和协商缓存的影响

1. 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。

2. 当f5刷新网页时，跳过强缓存，但是会检查协商缓存。

3. 浏览器地址栏中写入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）

